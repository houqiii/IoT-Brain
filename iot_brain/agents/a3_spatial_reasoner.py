# iot_brain/agents/a3_spatial_reasoner.py

import json
from typing import Dict, Any, Optional
from pathlib import Path

# Import the base class from the same directory.
from .base_agent import BaseAgent

class SpatialReasoner(BaseAgent):
    """
    The third agent in the IoT-Brain pipeline: Spatial Reasoner.
    
    This agent's responsibility is to review the sequence of decomposed atomic tasks
    and generate specific, actionable hypotheses for each task that requires
    verification. It bridges the gap between the high-level logical plan and the
    concrete, physical-world checks that need to be performed by the next agent.
    """
    def __init__(
        self,
        system_prompt: str,
        model_name: str,
        api_key: Optional[str] = None,
        base_url: Optional[str] = None,
    ):
        """
        Initializes the SpatialReasoner agent.

        Args:
            system_prompt (str): The system prompt string that defines the agent's role and instructions.
            model_name (str): The name of the Large Language Model to be used.
            api_key (Optional[str]): The API key for the LLM service.
            base_url (Optional[str]): A custom base URL for the LLM API endpoint.
        """
        super().__init__(
            agent_name="SpatialReasoner",
            system_prompt=system_prompt,  # Pass the prompt string directly.
            model_name=model_name,
            api_key=api_key,
            base_url=base_url
        )

    def generate_hypotheses(self, decomposed_plan: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Generates hypotheses for a decomposed plan.

        This method takes the plan from the SemanticDecomposer, which contains a list
        of atomic tasks, and prompts the LLM to annotate each task with a list of
        verifiable hypotheses.

        Args:
            decomposed_plan (Dict[str, Any]): The plan containing atomic sub-tasks, generated by SemanticDecomposer.

        Returns:
            Optional[Dict[str, Any]]: An updated plan where each task is now annotated
                                      with a 'hypotheses' list, if successful. Returns None on failure.
        """
        objective = decomposed_plan.get('task_objective', 'N/A')
        print(f"[{self.agent_name}] Generating hypotheses for plan: '{objective[:50]}...'")

        # The entire decomposed plan is serialized to a JSON string and sent to the LLM.
        user_input_str = json.dumps(decomposed_plan, indent=2)

        # The LLM is expected to return a modified version of the plan with hypotheses added.
        hypothesized_plan = self.execute(user_input=user_input_str, json_output=True)

        # Validate the structure of the returned plan.
        if hypothesized_plan and self._validate_hypotheses(hypothesized_plan):
            print(f"[{self.agent_name}] Hypotheses generation successful.")
            return hypothesized_plan
        else:
            print(f"[{self.agent_name}] Failed to generate a valid hypothesized plan.")
            return None

    def _validate_hypotheses(self, plan: Dict[str, Any]) -> bool:
        """
        Validates that the returned plan contains a corrected list of tasks,
        each with a 'hypotheses' key.

        Args:
            plan (Dict[str, Any]): The JSON object (as a dictionary) returned by the LLM.

        Returns:
            bool: True if the plan structure is valid, False otherwise.
        """
        if 'corrected_atomic_sub_tasks' not in plan:
            print(f"[{self.agent_name}] Validation Error: Missing 'corrected_atomic_sub_tasks'.")
            return False
        
        tasks = plan['corrected_atomic_sub_tasks']
        if not isinstance(tasks, list):
            print(f"[{self.agent_name}] Validation Error: 'corrected_atomic_sub_tasks' is not a list.")
            return False
            
        # Ensure every task object has a 'hypotheses' key, even if the list is empty.
        for i, task in enumerate(tasks):
            if 'hypotheses' not in task:
                print(f"[{self.agent_name}] Validation Error: Task {i} is missing the 'hypotheses' key.")
                return False
                
        return True