# iot_brain/agents/a2_semantic_decomposer.py

import json
from typing import Dict, Any, Optional
from pathlib import Path

# Import the base class from the same directory.
from .base_agent import BaseAgent

class SemanticDecomposer(BaseAgent):
    """
    The second agent in the IoT-Brain pipeline: Semantic Decomposer.
    
    This agent takes the initial, high-level Spatial Trajectory Graph (STG) and
    decomposes the user's overarching goal into a detailed sequence of logically
    indivisible, atomic sub-tasks. This creates a structured, step-by-step plan
    that subsequent agents can follow.
    """
    def __init__(
        self,
        system_prompt: str,
        model_name: str,
        api_key: Optional[str] = None,
        base_url: Optional[str] = None,
    ):
        """
        Initializes the SemanticDecomposer agent.

        Args:
            system_prompt (str): The system prompt string that defines the agent's role and instructions.
            model_name (str): The name of the Large Language Model to be used.
            api_key (Optional[str]): The API key for the LLM service.
            base_url (Optional[str]): A custom base URL for the LLM API endpoint.
        """
        super().__init__(
            agent_name="SemanticDecomposer",
            system_prompt=system_prompt,  # Pass the prompt string directly.
            model_name=model_name,
            api_key=api_key,
            base_url=base_url
        )

    def decompose_stg(self, initial_stg: Dict[str, Any], original_query: str) -> Optional[Dict[str, Any]]:
        """
        Decomposes the initial STG into a list of atomic tasks.

        This agent has a more complex input requirement than others. It needs both
        the user's original query for context and the initial STG from the
        TopologicalAnchor. These are combined into a single JSON string to be
        sent to the LLM.

        Args:
            initial_stg (Dict[str, Any]): The initial STG generated by TopologicalAnchor.
            original_query (str): The user's original query to provide full context.

        Returns:
            Optional[Dict[str, Any]]: A dictionary containing the overall task objective and a
                                      list of atomic sub-tasks if successful. Returns None on failure.
        """
        print(f"[{self.agent_name}] Decomposing STG for objective: '{initial_stg.get('objective', 'N/A')}'")

        # Key Step: Construct the specific input format for this agent.
        # We combine multiple pieces of information into a single JSON payload
        # which is then passed as a string to the parent's `execute` method.
        user_input_payload = {
            "original_query": original_query,
            "stg_json": initial_stg
        }
        user_input_str = json.dumps(user_input_payload, indent=2)

        # Call the execute method, expecting a JSON object representing the decomposed plan.
        decomposed_plan = self.execute(user_input=user_input_str, json_output=True)

        # Validate the structure of the returned plan.
        if decomposed_plan and self._validate_plan(decomposed_plan):
            print(f"[{self.agent_name}] STG decomposition successful.")
            return decomposed_plan
        else:
            print(f"[{self.agent_name}] Failed to generate a valid decomposed plan.")
            return None

    def _validate_plan(self, plan: Dict[str, Any]) -> bool:
        """
        A simple validation function to ensure the returned JSON contains the necessary keys.

        Args:
            plan (Dict[str, Any]): The JSON object (as a dictionary) returned by the LLM.

        Returns:
            bool: True if the plan is valid, False otherwise.
        """
        if 'task_objective' not in plan or 'atomic_sub_tasks' not in plan:
            print(f"[{self.agent_name}] Validation Error: Missing 'task_objective' or 'atomic_sub_tasks'.")
            return False
        if not isinstance(plan['atomic_sub_tasks'], list):
            print(f"[{self.agent_name}] Validation Error: 'atomic_sub_tasks' should be a list.")
            return False
        return True